\documentclass{standalone}
\usepackage{thesis}

\begin{document}
\pagestyle{headings}

\chapter{Implementacja}

\section{Wprowadzenie}

W rozdziale tym zostaną opisane szczegóły implementacji projektu. Opisane zostaną zarówno wykorzystane
narzędzia, sposób organizacji kodu jak i informacje na temat zastosowanych rozwiązań. Rozdział ten nie będzie
się koncentrował na przeglądzie kodu źródłowego (jego przykłady dostępne będą w Dodatku A), ale raczej na
wykorzystanych algorytmach i strukturach danych. Na koniec omówione zostaną praktyki przyjęte w projekcie aby
umożliwić stworzenie wysokiej jakości kodu.

\subsection{Użyte narzędzia}

Biblioteka \LIB{GLPK} wykorzystana w tym projekcie napisana została w języku \LANG{C}. Z tego powodu język,
w których docelowo miał zostać zrealizowany projekt powinien udostępniać możliwość wykorzystywania bibliotek
języka \LANG{C} za pośrednictwem adapterów bądź bezpośrednio. Po uwzględnieniu narzędzi istniejących dla
poszczególnych języków zdecydowano się na wybór języka \LANG{C++} - adaptacja bibliotek z \LANG{C} jest
naturalna, a przy tym sam język udostępnia możliwość programowania obiektowego, jak i dużą elastyczność przy
zachowaniu szybkości działania.

Kolejnym istotnym argumentem za \LANG{C++} było dostępność bibliotek i pakietów do tworzenia parserów gramatyk
bezkontekstowych - w projekcie do stworzenia parsera wczytującego dane wykorzystane zostały \PROG{flex} oraz
\PROG{bison}. Umożliwiają one utworzenie bardzo wydajnego parsera \CODE{LALR(1)}, zdolnego do uruchamiania
zdefiniowanego kodu \LANG{C}/\LANG{C++}.

Projekt wykorzystuje również bibliotekę \LIB{Boost} - z wyjątkiem kilku miejsc \LIB{Boost.Container} całkowicie
zastąpiła w nim bibliotekę \LIB{STL}, pozostałe komponenty biblioteki \LIB{Boost} zostały użyte do uzupełnienia
biblioteki \LIB{STL}.

\subsection{Wewnętrzna struktura projektu}

Ostatecznie całość programu została napisana w języku \LANG{C++}. (Niemal) wszystkie komponenty umieszczono we
wspólnej przestrzeni nazw \CODE{GT}, przy czym klasy zostały pogrupowane w kolejne 4 podprzestrzenie nazw:
\begin{itemize}
\item \CODE{Model} - zawiera klasy implementujące model danych bądź powiązane,
\item \CODE{Routines} - zawiera procedury obliczające równowagi Nasha dla poszczególnych rodzajów gier,
\item \CODE{GTL} - zawiera klasy parsera danych wejściowych,
\item \CODE{Program} - zawiera klasy powiązane z utworzeniem pliku wykonywalnego parsera.
\end{itemize}

\section{Model danych}

Ze względu na odmienne założenia odnośnie danych dla gier w formie strategicznej oraz gier w formie
ekstensywnej, dla każdego rodzaju gry zdefiniowano osobny model danych (jednak tam gdzie to możliwe
uwspólniono ich interfejs).

Przyjęto założenie, że raz utworzonego modelu danych nie modyfikuje się - z tego powodu wszystkie gotowe
instancje przechowuje się przy pomocy inteligentnych wskaźników na stałe obiekty - zmniejsza to narzut
związany z kopiowaniem obiektów, a także umożliwia zastosowanie co bardzie kosztownych operacji jako
jednorazowy narzut związany z utworzeniem obiektu.

\subsection{Gracz}

Wspólnym elementem interfejsu są przede wszystkim instancje graczy. Każda z nich przechowuje informację na
temat nazwy identyfikującej gracza, a także tablicę zawierającą strategię i mapę jego indeksów strategii -
dzięki temu znalezienie nazwy strategii na podstawie nr jest możliwe w czasie $O(1)$, zaś nr indeksu na
podstawie nazwy w czasie $O(log\;\ABS{S})$ (gdzie $\ABS{S}$ to liczba strategii gracza) - obie te informacje
są bardzo często wykorzystywane, więc szybkie ich przeliczanie warte jest jednorazowego narzutu związanego
z wypełnieniem dwóch osobnych struktur danych.

\subsection{Wartości funkcji wypłaty dla podanych strategii}

Wartości wypłaty wszystkich graczy dla danej kombinacji strategii czystych zamknięto w osobnym obiekcie
danych - jest on kolejnym wspólnym elementem interfejsu. Obiekt ten zwraca wypłatę dla danego gracza -
wewnętrzna reprezentacja danych zrealizowana jest przy pomocy mapy, aby zminimalizować czas dostępu do
żądanej wartości ($O(log\;n)$ dla $n$ graczy).

\subsection{Gry w formie strategicznej}

Ponieważ nie przyjęto odgórnego założenia na temat liczby graczy oraz ich strategi czystych, nie można było
stworzyć modelu danych opartego na wielowymiarowej tablicy danych. Zamiast tego zdecydowano się wewnętrznie
przechowywać dane w tablicy jednowymiarowej przy pomocy funkcji mieszającej.

Oznaczmy przez $\ABS{S_i}$ liczbę strategii gracza $i$ (gdzie $i = 1, 2, ..., n$).

Oznaczmy przez $H_1 = 1$ oraz $H_i = H_{i-1} * \ABS{S_i}$.

Oznaczmy przez $s \in S$ krotkę zawierająca po 1 strategii czystej każdego gracza, zaś $s_i$ ową strategię
dla gracza $i$.

Przypiszmy wszystkim strategiom $s_i$ gracza $i$ unikalną liczbę porządkową $O_i(s_i) = 0, 1, ..., \ABS{S_i}-1$.

Wówczas funkcję mieszającą można zdefiniować jako:
$$h(s) = \sum\limits_{i=0}^{n-1} H_i O_i(s_i)$$

\begin{theorem}
Tak zdefiniowana funkcja hashująca jest bijekcją ze zbioru $S$ w $ \ZZ \cap [0, \prod\limits_{i=1}^{n} \ABS{S_i}] $.
\end{theorem}

TODO

\subsection{Gry w formie ekstensywnej}

Gry w postaci ekstensywnej opisują struktury w formie drzewa i tak też są implementowane w programie. Każdemu
wierzchołkowi w grafie opowiada obiekt wierzchołka przechowujący mapę potomków - rozwiązane uznano za mniej problematyczne
niż tablica hashująca ze względu na brak wymogu obecności każdej zadeklarowanej strategii gracza podejmującego decyzję w danym
wierzchołku w zbiorze potomków tego wierzchołka.

Funkcja wypłaty przeszukuje drzewo i zwraca wartości przechowywane w odnalezionym węźle.

\section{Procedury obliczające równowagi}

\subsection{Gry w formie strategicznej}

Ponieważ nie jest znany żaden wydajny algorytm odnajdywania równowagi w strategiach czystych w grach strategicznych konieczne
jest przeszukanie całej przestrzeni rozwiązań - testowania każdej kombinacji strategii jako potencjalnej równowagi Nasha.
Jedyną możliwą do zastosowania optymalizacją jest eliminacja strategii zdominowanych, nie gwarantuje ona jednak, że wyeliminowane
zostanie jakaś znacząca ilość strategii (w najgorszym przypadku żadna).

Program korzysta z odwracalności przyjętej funkcji hashującej iterować po wszystkich wartościach hasha, odzyskiwać z nich krotkę
strategii i testować ją pod względem wyznaczania równowagi Nasha.

Strategie mieszane w grach jedno- i dwumacierzowych jako obliczane przy pomocy algorytmu Simpleks są obliczane przez proste wypełnienie
modeli biblioteki \LIB{GLPK} i oddelegowanie obliczenia wartości problemu liniowego/całkowitoliczbowego na jej procedury.

\subsection{Gry w formie ekstensywnej}

Rozważane są wyłącznie gry z informacją doskonałą - mają one tą przyjemną własność, że w każdym wierzchołku jeśli
tylko obliczymy optymalny wybór dla synów danego wierzchołka możemy wybrać strategię dla samego wierzchołka - wybieramy
zawsze tą, która posiada największą wypłatę dla gracza decydującego w danych wierzchołku. Możliwe jest więc obliczenie
równowagi Nasha rekurencyjnie - dla każdego wierzchołka obliczamy wypłaty oraz decyzje jego synów, po czym wybieramy najbardziej
korzystny wariant i zwracamy (zarówno wypłatę jak i decyzje podjęte w wierzchołkach potomnych). Na samym końcu będziemy posiadali
wartości wypłaty w punkcie równowagi oraz decyzje podjęte przez graczy w każdym z wierzchołków.

\section{Parser danych wejściowych}

Za przetwarzanie danych wejściowych odpowiada parser napisany przy pomocy pakietów \LIB{Flex} oraz \LIB{Bison}. Ponieważ przy ich
pomocy tworzy się parsery typu LALR możliwe jest pisane przejrzystej łatwej w łatwej w rozwijaniu gramatyki, zaś wyjściowy kod jest
wydajny i bezpieczny.

\section{Praktyki przyjęte w projekcie}

W projekcie przyjęto pewne zasady pozwalające na lepszą organizację oraz łatwiejsze poruszanie się po kodzie. Przede wszystkim
projekt podzielony został na moduły:
\begin{itemize}
\item \MODULE{model} - zawiera definicje modeli, oraz metod dostępowych do przechowywanych w nich danych,
\item \MODULE{routines} - zawiera definicje algorytmów obliczających równowagi w poszczególnych rodzajach gier,
\item \MODULE{gtl} - zawiera definicje parsera oraz klas reprezentujących poszczególne wierzchołki drzewa składniowego,
\item \MODULE{program} - zawiera definicje oraz funkcje używane przy uruchamianiu programu.
\end{itemize}

Projekt został również podzielony na 2 nadrzędne katalogi:
\begin{itemize}
\item \MODULE{include} - zawiera publiczne nagłówki, które powinny być widoczne dla programistów chcących korzystać wyłącznie z biblioteki
ale nie z programu wykonywalnego. Większość deklaracji stanowią interfejsy oraz fabryki pozwalające uzyskać dostęp do implementacji,
zadeklarowanych klas,
\item \MODULE{src} - zawiera wewnętrzne nagłówki oraz implementacje publicznych interfejsów.
\end{itemize}
Ponieważ większość klas jest udostępniana wyłączne jako interfejsy, użytkownicy nie są zależni od większości zmian w wewnętrznym uporządkowaniu
programu, wykorzystanych algorytmach oraz innych szczegółach implementacji podatnych na zmiany.

\end{document}

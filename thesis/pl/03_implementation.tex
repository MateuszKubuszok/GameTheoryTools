\documentclass[polish]{standalone}
\usepackage{thesis}

\begin{document}
\pagestyle{headings}

\chapter{Implementacja}

\section{Wprowadzenie}

W rozdziale tym zostaną opisane szczegóły implementacji projektu. Uwzględnia to zarówno wykorzystane narzędzia, sposób
organizacji kodu jak i informacje na temat zastosowanych rozwiązań. Rozdział ten nie będzie się koncentrował na
przeglądzie kodu źródłowego (jego przykłady dostępne będą w Dodatku A), ale raczej na wykorzystanych algorytmach i
strukturach danych. Na koniec omówione zostaną praktyki przyjęte w projekcie aby umożliwić stworzenie wysokiej jakości
kodu.

\subsection{Użyte narzędzia}

Biblioteka \LIB{GLPK} wykorzystana w tym projekcie napisana została w języku \LANG{C}. Z tego powodu język, w których
docelowo miał zostać zrealizowany projekt powinien udostępniać możliwość wykorzystywania bibliotek języka \LANG{C} za
pośrednictwem adapterów bądź bezpośrednio. Po uwzględnieniu narzędzi istniejących dla poszczególnych języków zdecydowano
się na wybór języka \LANG{C++} - adaptacja bibliotek z \LANG{C} jest naturalna, a przy tym sam język udostępnia
możliwość programowania obiektowego, jak i dużą elastyczność przy zachowaniu szybkości działania.

Kolejnym istotnym argumentem za \LANG{C++} było dostępność bibliotek i pakietów do tworzenia parserów gramatyk
bezkontekstowych - w projekcie do stworzenia parsera wczytującego dane wykorzystane zostały \PROG{flex} oraz
\PROG{bison}. Umożliwiają one utworzenie bardzo wydajnego parsera \CODE{LALR(1)}, zdolnego do uruchamiania
zdefiniowanego kodu \LANG{C}/\LANG{C++}.

Projekt wykorzystuje również bibliotekę \LIB{Boost} - z wyjątkiem kilku miejsc \LIB{Boost.Container} całkowicie
zastąpiła w nim bibliotekę \LIB{STL}, pozostałe komponenty biblioteki \LIB{Boost} zostały użyte do uzupełnienia
biblioteki \LIB{STL}.

\subsection{Wewnętrzna struktura projektu}

Ostatecznie całość programu została napisana w języku \LANG{C++}. (Niemal) wszystkie komponenty umieszczono we wspólnej
przestrzeni nazw \CODE{GT}, przy czym klasy zostały pogrupowane w kolejne 4 podprzestrzenie nazw:
\begin{itemize}
\item \CODE{Model} - zawiera klasy implementujące model danych bądź powiązane,
\item \CODE{Routines} - zawiera procedury obliczające równowagi Nasha dla poszczególnych rodzajów gier,
\item \CODE{GTL} - zawiera klasy parsera danych wejściowych,
\item \CODE{Program} - zawiera klasy powiązane z utworzeniem pliku wykonywalnego parsera.
\end{itemize}

\section{Model danych}

Ze względu na odmienne założenia odnośnie danych dla gier w formie strategicznej oraz ekstensywnej, dla każdego rodzaju
gry zdefiniowano osobny model danych (jednak tam gdzie to możliwe uwspólniono ich interfejs).

Przyjęto założenie, że raz utworzonego modelu danych nie modyfikuje się - z tego powodu wszystkie gotowe instancje
przechowuje się przy pomocy inteligentnych wskaźników na stałe obiekty - zmniejsza to narzut związany z kopiowaniem
obiektów, a także umożliwia zastosowanie co bardzie kosztownych operacji jako jednorazowy narzut związany z utworzeniem
obiektu.

\subsection{Gracz}

Wspólnym elementem interfejsu są przede wszystkim instancje graczy. Każda z nich przechowuje informację na temat nazwy
identyfikującej gracza, a także tablicę zawierającą strategię i mapę jego indeksów strategii - dzięki temu znalezienie
jej nazwy na podstawie numeru jest możliwe w czasie $O(1)$, zaś nr indeksu na podstawie nazwy w czasie 
$O(log\;\ABS{S})$ (gdzie $\ABS{S}$ to liczba strategii gracza) - obie te informacje są bardzo często wykorzystywane,
więc szybkie ich przeliczanie warte jest jednorazowego narzutu związanego z wypełnieniem dwóch osobnych struktur danych.

\subsection{Wartości funkcji wypłaty dla podanych strategii}

Wartości wypłaty wszystkich graczy dla danej kombinacji strategii czystych zamknięto w osobnym obiekcie danych - jest on
kolejnym wspólnym elementem interfejsu. Obiekt ten zwraca wypłatę dla danego gracza - wewnętrzna reprezentacja danych
zrealizowana jest przy pomocy mapy, aby zminimalizować czas dostępu do żądanej wartości ($O(log\;n)$ dla $n$ graczy).

\subsection{Gry w formie strategicznej}

Ponieważ nie przyjęto odgórnego założenia na temat liczby graczy oraz ich strategi czystych, nie można było stworzyć
modelu danych opartego na wielowymiarowej tablicy danych. Zamiast tego zdecydowano się wewnętrznie przechowywać dane
w tablicy jednowymiarowej przy pomocy funkcji mieszającej.

Oznaczmy przez $\ABS{S_i}$ liczbę strategii gracza $i$ (gdzie $i = 1, 2, ..., n$).

Oznaczmy przez $H_1 = 1$ oraz $H_i = H_{i-1} * \ABS{S_i}$.

Oznaczmy przez $s \in S$ krotkę zawierająca po 1 strategii czystej każdego gracza, zaś $s_i$ ową strategię
dla gracza $i$.

Przypiszmy wszystkim strategiom $s_i$ gracza $i$ unikalną liczbę porządkową $O_i(s_i) = 0, 1, ..., \ABS{S_i}-1$.

Wówczas funkcję mieszającą można zdefiniować jako:
$$h(s) = \sum\limits_{i=0}^{n-1} H_i O_i(s_i)$$

\begin{theorem}
Tak zdefiniowana funkcja hashująca jest bijekcją ze zbioru $S$ w $ \ZZ \cap [0, \prod\limits_{i=1}^{n} \ABS{S_i}] $.
\end{theorem}

\begin{proof}
Dla $n = 1$ jest to oczywiste. Dla $n > 1$ wystarczy zauważyć, że z definicji jeśli tylko byłaby to bijekcja dla $n-1$
to na pewno będzie nią dla $n$.
\end{proof}

W ogólności funkcje hashujące nie są wykorzystywane w ten sposób i wymaga się od nich zazwyczaj szybkości oraz bycia
trudnymi do odwrócenia. Tutaj jednak używane są do indeksowania tablicy asocjacyjnej i ich odwracalność jest przydatną
właściwością - pozwala łatwo odzyskać profil na podstawie przydzielonego mu indeksu tablicy.

\subsection{Gry w formie ekstensywnej}

Gry w postaci ekstensywnej opisują struktury w formie drzewa i tak też są implementowane w programie. Każdemu 
wierzchołkowi w grafie opowiada obiekt wierzchołka przechowujący mapę potomków - rozwiązane uznano za mniej
problematyczne niż tablica hashująca ze względu na brak wymogu obecności każdej zadeklarowanej strategii gracza
podejmującego decyzję w danym wierzchołku w zbiorze potomków tego wierzchołka.

Funkcja wypłaty przeszukuje drzewo i zwraca wartości przechowywane w odnalezionym węźle.

\section{Procedury obliczające równowagi}

\subsection{Gry w formie strategicznej}

Ponieważ nie jest znany żaden wydajny algorytm odnajdywania równowagi w strategiach czystych w grach strategicznych
konieczne jest przeszukanie całej przestrzeni rozwiązań - testowania każdej kombinacji strategii jako potencjalnej
równowagi Nasha. Jedyną możliwą do zastosowania optymalizacją jest eliminacja strategii zdominowanych, nie gwarantuje
ona jednak, że wyeliminowane zostanie jakaś znacząca ilość strategii (w najgorszym przypadku żadna).

Program korzysta z odwracalności przyjętej funkcji hashującej iterować po wszystkich wartościach hasha, odzyskiwać
z nich krotkę strategii i testować ją pod względem wyznaczania równowagi Nasha.

Strategie mieszane w grach jedno- i dwumacierzowych jako obliczane przy pomocy algorytmu Simpleks są otrzymywane przez
proste wypełnienie modeli biblioteki \LIB{GLPK} i oddelegowanie obliczenia wartości problemu
liniowego/całkowitoliczbowego na jej procedury.

\subsubsection{Gry jednomacierzowe}

Problem zapisano w języku \LANG{MathProg} następująco:

\begin{code}[caption=Przykładowe dane]
data;
 
set P1S := a b c;
set P2S := 1 2 3 4;
 
param Payoff
    :  1  2  3  4 :=
    a  -5 3  1  8
    b  5  5  4  6
    c  -4 6  0  5;
 
end;
\end{code}

\begin{code}[caption=Rozwiązanie dla gracza pierwszego]
set P1S;
set P2S;
 
param Payoff{P1S, P2S};
 
var y{P1S} >= 0;
 
minimize GameValue: sum{i in P1S} y[i];
 
s.t. Condition2{j in P2S}:
    sum{i in P1S} Payoff[i,j] * y[i] >= 1;
 
solve;
 
printf "Value: %s\n", GameValue;
 
printf "Player 1 strategies:\n";
 
for{i in P1S}
    printf "Found %s, actual %s\n", y[i], y[i]/GameValue; 
 
end;
\end{code}

\begin{code}[caption=Rozwiązanie dla gracza drugiego]
set P1S;
set P2S;
 
param Payoff{P1S, P2S};
 
var x{P2S} >= 0;
 
maximize GameValue: sum{j in P2S} x[j];
 
s.t. Condition1{i in P1S}:
    sum{j in P2S} Payoff[i,j] * x[j] <= 1;
 
solve;
 
printf "Value: %s\n", GameValue;
 
printf "Player 2 strategies:\n";
 
for{j in P2S}
    printf "Found %s, actual %s\n", x[j], x[j]/GameValue;
 
end;
\end{code}

\subsubsection{Gra dwumacierzowa}

Problem zapisano w jeżyku \LANG{MathProg} następująco:

\begin{code}[caption=Przykładowe dane]
data;
 
set P1S := a b c;
set P2S := 1 2 3 4;
 
param Payoff1
    :  1  2  3  4 :=
    a  0  3  1  8
    b  5  5  4  6
    c  2  6  0  5;
 
param Payoff2
    :  1  2  3  4 :=
    a  6  6  2  2
    b  3  2  5  6
    c  0  7  0  1;
 
end;
\end{code}

\begin{code}[caption=Szukanie rozwiązania]
set P1S;
set P2S;
 
param Payoff1{P1S, P2S};
param Payoff2{P1S, P2S};
 
param U1 := max{i in P1S, j in P2S}
  Payoff1[i,j] - min{i in P1S, j in P2S} Payoff1[i,j];
param U2 := max{i in P1S, j in P2S}
  Payoff2[i,j] - min{i in P1S, j in P2S} Payoff2[i,j];
 
var b1s{P1S}, binary;
var b2s{P2S}, binary;
 
var p1s{P1S}, >= 0, <=1;
var p2s{P2S}, >= 0, <=1;
 
var u1s{P1S};
var u2s{P2S};
 
var r1s{P1S};
var r2s{P2S};
 
var u1;
var u2;
 
minimize AvarageRegret:
  ( sum{i in P1S} r1s[i] + sum{j in P2S} r2s[j] ) / 2;
 
s.t. Probabilities1:
	sum{i in P1S} p1s[i] = 1;
s.t. Probabilities2:
	sum{j in P2S} p2s[j] = 1;
 
s.t. UtilitiesValue1{i in P1S}:
	u1s[i] = sum{j in P2S} p2s[j] * Payoff1[i,j];
s.t. UtilitiesValue2{j in P2S}:
	u2s[j] = sum{i in P1S} p1s[i] * Payoff2[i,j];
 
s.t. MaxUtilities1{i in P1S}:
	u1 >= u1s[i];
s.t. MaxUtilities2{j in P2S}:
	u2 >= u2s[j];
 
s.t. Regret1{i in P1S}:
	r1s[i] = u1 - u1s[i];
s.t. Regret2{j in P2S}:
	r2s[j] = u2 - u2s[j];
 
s.t. Probability1{i in P1S}:
	p1s[i] <= 1 - b1s[i];
s.t. Probability2{j in P2S}:
	p2s[j] <= 1 - b2s[j];
 
s.t. RegretAndMax1{i in P1S}:
	r1s[i] <= U1 * b1s[i];
s.t. RegretAndMax2{j in P2S}:
	r2s[j] <= U2 * b2s[j];
 
solve;
 
printf "Player 1 strategies:\n";
for{i in P1S}
	printf "%s -> %s\n", i, p1s[i];
printf "Sum = %s, \n", sum{i in P1S} p1s[i] * u1s[i];
printf "Max = %s, \n", U1;
 
printf "Player 2 strategies:\n";
for{j in P2S}
	printf "%s -> %s\n", j, p2s[j];
printf "Sum = %s, \n", sum{j in P2S} p2s[j] * u2s[j];
printf "Max = %s, \n", U2;
\end{code}

Dla testów wybrano następującą funkcję celu:
$$\textbf{minimalizuj} \frac{\sum_{s_1 \in S_1} r_{s_1} + \sum_{s_2 \in S_2} r_{s_2}}{2}$$
minimalizującą średnią wartość żalu przy założeniu rozkładu jednostajnego. Możliwym usprawnieniem jest zmiana na któreś
z rozwiązań zaproponowanym przez autorów oryginalnej pracy.

\subsection{Gry w formie ekstensywnej}

Rozważane są wyłącznie gry z informacją doskonałą. Aby zaleźć w nich równowagę Nasha rekurencyjnie obliczamy wartości
podgier dla każdego z wierzchołków. W wywołaniach przekazujemy listę na którą dopisujemy optymalny wybór dla danego
gracza. Po obliczeniu wartości dla wszystkich strategii, wybieramy najlepszą, dopisujemy ją do listy i zwracamy wartość
gry. Po zakończeniu otrzymujemy listę wybranych strategii (równowagę Nasha) oraz wypłaty graczy.

\section{Parser danych wejściowych}

Za przetwarzanie danych wejściowych odpowiada parser napisany przy pomocy pakietów \LIB{Flex} oraz \LIB{Bison}. Ponieważ
przy ich udziale tworzy się parsery typu LALR możliwe jest pisane przejrzystej łatwej w rozwijaniu gramatyki, zaś 
wyjściowy kod jest wydajny i bezpieczny.

\section{Praktyki przyjęte w projekcie}

W projekcie przyjęto pewne zasady pozwalające na lepszą organizację oraz łatwiejsze poruszanie się po kodzie. Przede
wszystkim projekt podzielony został na moduły:
\begin{itemize}
\item \MODULE{model} - zawiera definicje modeli, oraz metod dostępowych do przechowywanych w nich danych,
\item \MODULE{routines} - zawiera definicje algorytmów obliczających równowagi w poszczególnych rodzajach gier,
\item \MODULE{gtl} - zawiera definicje parsera oraz klas reprezentujących poszczególne wierzchołki drzewa składniowego,
\item \MODULE{program} - zawiera definicje oraz funkcje używane przy uruchamianiu programu.
\end{itemize}

Projekt został również podzielony na 2 nadrzędne katalogi:
\begin{itemize}
\item \MODULE{include} - zawiera publiczne nagłówki, które powinny być widoczne dla programistów chcących korzystać
wyłącznie z biblioteki ale nie z programu wykonywalnego. Większość deklaracji stanowią interfejsy oraz fabryki
pozwalające uzyskać dostęp do implementacji, zadeklarowanych klas,
\item \MODULE{src} - zawiera wewnętrzne nagłówki oraz implementacje publicznych interfejsów.
\end{itemize}
Ponieważ większość klas jest udostępniana wyłączne jako interfejsy, użytkownicy nie są zależni od większości zmian
w wewnętrznym uporządkowaniu programu, wykorzystanych algorytmach oraz innych szczegółach implementacji podatnych
na zmiany.

\end{document}
